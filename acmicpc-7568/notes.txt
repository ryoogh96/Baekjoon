덩치 표기법 (x,y) x = 몸무게 y = 키 

(몸무게, 키)

두 사람 A 와 B의 덩치가 각각 (x,y), (p,q)라고 할 때 x>p 그리고 y>q 이라면 
우리는 A의 덩치가 B의 덩치보다 "더 크다"고 말한다
즉 몸무게 키가 둘다 커야 덩치가 크다고 한다.

사람의 덩치 등수는 자신보다 더 큰 덩치의 사람의 수로 정해진다.

만일 자신보다 더 큰 덩치의 사람이 k명이라면 그 사람의 덩치 등수는 k+1이 된다. 


계획

두 사람끼리 비교를 할때의 경우의 수

1) 몸무게와 키가 어느 한쪽이 클때 -> 큰 값의 덩치 등수 

2) 몸무게나 키 둘중 한쪽만 클때 -> 같은 값의 덩치 등수

3) 몸무게와 키 둘다 같을때 -> 같은 값의 덩치 등수


계획

몸무게와 키를 가지는 fat 구조체를 선언한다.



//몸무게와 키 둘다 큰 애들만 정렬하고 나머지는 마지막 랭크넘버를 할당해준다.

// 원래 순서대로 등수를 출력해야해서 sort는 아무런 의미가 없다.
// 그러므로 struct에 i번째 배열값을 넣고 출력한다.
sort로 일단 먼저 몸무게 순으로 나열한다.

Before
5
55 185
58 183
88 186
60 175
46 155

After
5
88 186
60 175
58 183
55 185
46 155


비교할때 둘다 크지 않으면 같은 랭크넘버를 할당해준다.
Before
5
50 150				    2
50 100	// 몸무게는 같은데 키만 다른경우  2
45 150  // 키는 같은데 몸무게만 다른경우  5 	
50 200  // 몸무게는 같은데 키가 큰 경우   2
60 150  // 키는 같은데 몸무게가 큰 경우   1

After 몸무게순으로만 정렬한 경우
60 150 // 1
50 150 // 1
50 100 // 5
50 200 // 1
45 150 // 1

After 몸무게와 키 둘다 큰 순으로 정렬한 경우
60 150 // 1
50 200 // 1
50 150 // 3
50 100 // 3
45 150 // 5


After 정렬한 상태에서 키 순으로 정렬 한 경우 // 성립되지 않음
50 200 // 2
60 150 // 1
50 150 // 2
45 150 // 5
50 100 // 2




n^2돌면서 자기보다 덩치가 큰 애가 있으면 rankNum++한다


위에거 다안되고 무지 간단한 문제였다

    int tmpRank = 0;
    for(int i = 0; i < n; i++)
        for(int j = 0; j < n; j++)       
            if(i!=j)
		{
		    if(Fat[i].weight < Fat[j].weight && Fat[i].height < Fat[j].height)
                    tmpRank++;
		}
	    }
		tmpRank = 0;
        }

if(Fat[i].weight < Fat[j].weight && Fat[i].height < Fat[j].height)

작은 경우에만 랭크를 1씩 더해주고 이 결과값을 출력해 주면 된다.