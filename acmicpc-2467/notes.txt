특성값을 모두 구한뒤 오름차 순으로 정렬 한다.

예제 입력

5
-99 -2 -1 4 98


-101 -100 -95 -1 -3 2 96 3 97 102


오름 차 순 정렬 뒤

-101 -100 -95 -3 -1 2 3 96 97 102

int min = solution[0];

내림 차 순 정렬 뒤

int max = solution[0];

forcnt = abs(min) + abs(max)

i= 1
cnt -= i;
0부터 cnt를 둬서 -1을 전체 배열 에서 for문으로 찾는다.
그 다음 cnt이 음수면 cnt += i+1 하고 for문으로 찾는다.


int cnt = -1;

for(int i = 2; i < min; i++)
    if(cnt < 0) cnt += i;
    else if(cnt > 0) cnt -= i;

그런데 이러한 풀이 방법은 n이 100000개라면 99999+ 99998...0으로 엄청난 시간이 걸리게된다.


예제 입력에서는 제일 작은값인 -99와 제일 큰 값인 98을 더해 0에서 가장 가까운 특성값을 구하였다.



5

-9 -5 1 4 7


-14 -8 -5 -2 -4 -1 2 5 8 11


특성값을 하나씪 구할 때 마다 

더하는 경우의 수 

1) 음수 끼리 더하는 수 -> 무조건 음수가 나온다.

2) 음수와 양수 혹은 양수와 음수 끼리 더하는 수 -> 양수가 크면 양수가 음수가 크면 음수가 나온다.

3) 양수 끼리 더하는 수 -> 무조건 양수가 나온다.


1 -> if(soluitons[i] < 0 && solutions[j] < 0) 




모든 특성값을 구하는 순간 이미 엄청난 시간이 초과되어 있기 때문에 모든 특성값을 다 구할 순 없다.




모든 특성값의 양 끝값 (최소값과 최대값) 부터 특성값을 구하기

그런 다음 특성값들의 절대값이 제일 작은 값의 양 끝값을 출력하면 답이다.

solution[i] + solution[n-i];

5

-11 -7 3 5 9


-18 -8 -6 -2 -4 -2 2 8 12 14



-11+9 = -2, -7 + 5 = -2

7

-13 -10 -5 1 4 9 13

0 -1 -1



2

1 1


4

1 2 3 4

1 + 2 = 3

// 위의 케이스에 성립하지 않는다.
모든 특성값의 양 끝값 (최소값과 최대값) 부터 특성값을 구하기

그런 다음 특성값들의 절대값이 제일 작은 값의 양 끝값을 출력하면 답이다.


입력값에 양수만 있을경우 solutions[0], solutions[1]가 정답


4


-4 -3 -2 -1



입력값에 음수만 있을경우 solutions[n-2], solutions[n-1]가 정답


4
0 0 0 0

모든 입력값이 0 일 경우 0 0 출력?




